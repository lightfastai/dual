package env

import (
	"os"
	"path/filepath"
	"strings"
	"testing"
	"time"

	"github.com/lightfastai/dual/internal/config"
	"github.com/lightfastai/dual/internal/registry"
)

func TestGenerateServiceEnvFiles(t *testing.T) {
	// Create temporary directory
	tempDir := t.TempDir()

	// Create test config
	cfg := &config.Config{
		Services: map[string]config.Service{
			"api": {
				Path:    "services/api",
				EnvFile: ".env",
			},
			"web": {
				Path:    "services/web",
				EnvFile: ".env",
			},
			"worker": {
				Path:    "services/worker",
				EnvFile: ".env",
			},
		},
	}

	// Create test registry
	reg := &registry.Registry{
		Projects: make(map[string]registry.Project),
	}

	// Create a context with overrides
	projectID := tempDir
	contextName := "test-context"

	// Add context with global and service-specific overrides
	reg.Projects[projectID] = registry.Project{
		Contexts: map[string]registry.Context{
			contextName: {
				Created: time.Now(),
				EnvOverridesV2: &registry.ContextEnvOverrides{
					Global: map[string]string{
						"DATABASE_URL": "postgres://localhost/global_db",
						"DEBUG":        "true",
					},
					Services: map[string]map[string]string{
						"api": {
							"DATABASE_URL": "postgres://localhost/api_db",
							"API_KEY":      "secret_key",
						},
						"web": {
							"FRONTEND_URL": "http://localhost:3000",
						},
					},
				},
			},
		},
	}

	// Generate service env files
	err := GenerateServiceEnvFiles(cfg, reg, tempDir, projectID, contextName)
	if err != nil {
		t.Fatalf("GenerateServiceEnvFiles failed: %v", err)
	}

	// Verify api service env file
	apiEnvPath := filepath.Join(tempDir, ".dual", ".local", "service", "api", ".env")
	apiContent, err := os.ReadFile(apiEnvPath)
	if err != nil {
		t.Fatalf("Failed to read api env file: %v", err)
	}
	apiStr := string(apiContent)

	// Check header
	if !strings.Contains(apiStr, "WARNING: This file is automatically generated by dual") {
		t.Error("api env file missing warning header")
	}
	if !strings.Contains(apiStr, "Context: test-context") {
		t.Error("api env file missing context name")
	}
	if !strings.Contains(apiStr, "Service: api") {
		t.Error("api env file missing service name")
	}

	// Check variables (api should have DATABASE_URL from service-specific, not global)
	if !strings.Contains(apiStr, "DATABASE_URL=postgres://localhost/api_db") {
		t.Error("api env file missing service-specific DATABASE_URL")
	}
	if !strings.Contains(apiStr, "API_KEY=secret_key") {
		t.Error("api env file missing API_KEY")
	}
	if !strings.Contains(apiStr, "DEBUG=true") {
		t.Error("api env file missing global DEBUG")
	}

	// Verify web service env file
	webEnvPath := filepath.Join(tempDir, ".dual", ".local", "service", "web", ".env")
	webContent, err := os.ReadFile(webEnvPath)
	if err != nil {
		t.Fatalf("Failed to read web env file: %v", err)
	}
	webStr := string(webContent)

	// Web should have global overrides + service-specific
	if !strings.Contains(webStr, "DATABASE_URL=postgres://localhost/global_db") {
		t.Error("web env file missing global DATABASE_URL")
	}
	if !strings.Contains(webStr, "DEBUG=true") {
		t.Error("web env file missing global DEBUG")
	}
	if !strings.Contains(webStr, "FRONTEND_URL=http://localhost:3000") {
		t.Error("web env file missing service-specific FRONTEND_URL")
	}

	// Verify worker service env file (should only have global overrides)
	workerEnvPath := filepath.Join(tempDir, ".dual", ".local", "service", "worker", ".env")
	workerContent, err := os.ReadFile(workerEnvPath)
	if err != nil {
		t.Fatalf("Failed to read worker env file: %v", err)
	}
	workerStr := string(workerContent)

	// Worker should only have global overrides
	if !strings.Contains(workerStr, "DATABASE_URL=postgres://localhost/global_db") {
		t.Error("worker env file missing global DATABASE_URL")
	}
	if !strings.Contains(workerStr, "DEBUG=true") {
		t.Error("worker env file missing global DEBUG")
	}
	if strings.Contains(workerStr, "API_KEY") {
		t.Error("worker env file should not have api-specific API_KEY")
	}
}

func TestGenerateServiceEnvFiles_NoOverrides(t *testing.T) {
	tempDir := t.TempDir()

	cfg := &config.Config{
		Services: map[string]config.Service{
			"api": {Path: "services/api"},
		},
	}

	reg := &registry.Registry{
		Projects: make(map[string]registry.Project),
	}

	projectID := tempDir
	contextName := "test-context"

	// Create context with no overrides
	reg.Projects[projectID] = registry.Project{
		Contexts: map[string]registry.Context{
			contextName: {
				Created: time.Now(),
			},
		},
	}

	err := GenerateServiceEnvFiles(cfg, reg, tempDir, projectID, contextName)
	if err != nil {
		t.Fatalf("GenerateServiceEnvFiles failed: %v", err)
	}

	// Verify no env files were created (sparse pattern)
	apiEnvPath := filepath.Join(tempDir, ".dual", ".local", "service", "api", ".env")
	if _, err := os.Stat(apiEnvPath); !os.IsNotExist(err) {
		t.Error("api env file should not exist when there are no overrides")
	}
}

func TestGenerateServiceEnvFiles_ContextNotFound(t *testing.T) {
	tempDir := t.TempDir()

	cfg := &config.Config{
		Services: map[string]config.Service{
			"api": {Path: "services/api"},
		},
	}

	reg := &registry.Registry{
		Projects: make(map[string]registry.Project),
	}

	// Generate for non-existent context (should not error, just skip)
	err := GenerateServiceEnvFiles(cfg, reg, tempDir, tempDir, "nonexistent")
	if err != nil {
		t.Fatalf("GenerateServiceEnvFiles should not error for missing context: %v", err)
	}
}

func TestGetRemappedVarsForService(t *testing.T) {
	tests := []struct {
		name        string
		ctx         *registry.Context
		serviceName string
		want        map[string]string
	}{
		{
			name: "global overrides only",
			ctx: &registry.Context{
				EnvOverridesV2: &registry.ContextEnvOverrides{
					Global: map[string]string{
						"DATABASE_URL": "postgres://localhost/db",
						"DEBUG":        "true",
					},
				},
			},
			serviceName: "api",
			want: map[string]string{
				"DATABASE_URL": "postgres://localhost/db",
				"DEBUG":        "true",
			},
		},
		{
			name: "service-specific overrides",
			ctx: &registry.Context{
				EnvOverridesV2: &registry.ContextEnvOverrides{
					Global: map[string]string{
						"DEBUG": "true",
					},
					Services: map[string]map[string]string{
						"api": {
							"API_KEY": "secret",
						},
					},
				},
			},
			serviceName: "api",
			want: map[string]string{
				"DEBUG":   "true",
				"API_KEY": "secret",
			},
		},
		{
			name: "service-specific overrides override global",
			ctx: &registry.Context{
				EnvOverridesV2: &registry.ContextEnvOverrides{
					Global: map[string]string{
						"DATABASE_URL": "postgres://localhost/global_db",
						"DEBUG":        "true",
					},
					Services: map[string]map[string]string{
						"api": {
							"DATABASE_URL": "postgres://localhost/api_db",
						},
					},
				},
			},
			serviceName: "api",
			want: map[string]string{
				"DATABASE_URL": "postgres://localhost/api_db",
				"DEBUG":        "true",
			},
		},
		{
			name: "PORT is treated as normal environment variable",
			ctx: &registry.Context{
				EnvOverridesV2: &registry.ContextEnvOverrides{
					Global: map[string]string{
						"PORT":  "3000",
						"DEBUG": "true",
					},
				},
			},
			serviceName: "api",
			want: map[string]string{
				"PORT":  "3000",
				"DEBUG": "true",
			},
		},
		{
			name: "no overrides",
			ctx: &registry.Context{
				EnvOverridesV2: &registry.ContextEnvOverrides{
					Global:   map[string]string{},
					Services: map[string]map[string]string{},
				},
			},
			serviceName: "api",
			want:        map[string]string{},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got, err := getRemappedVarsForService(tt.ctx, tt.serviceName)
			if err != nil {
				t.Fatalf("getRemappedVarsForService failed: %v", err)
			}

			if len(got) != len(tt.want) {
				t.Errorf("got %d vars, want %d vars", len(got), len(tt.want))
			}

			for k, v := range tt.want {
				if got[k] != v {
					t.Errorf("var %q: got %q, want %q", k, got[k], v)
				}
			}
		})
	}
}

func TestWriteServiceEnvFile(t *testing.T) {
	tempDir := t.TempDir()

	vars := map[string]string{
		"DATABASE_URL": "postgres://localhost/db",
		"API_KEY":      "secret_key",
		"DEBUG":        "true",
	}

	outputPath := filepath.Join(tempDir, ".dual", ".local", "service", "api", ".env")
	err := writeServiceEnvFile("api", "test-context", vars, outputPath)
	if err != nil {
		t.Fatalf("writeServiceEnvFile failed: %v", err)
	}

	// Verify file exists
	content, err := os.ReadFile(outputPath)
	if err != nil {
		t.Fatalf("Failed to read env file: %v", err)
	}

	str := string(content)

	// Check header
	if !strings.Contains(str, "WARNING: This file is automatically generated by dual") {
		t.Error("missing warning header")
	}
	if !strings.Contains(str, "Context: test-context") {
		t.Error("missing context name")
	}
	if !strings.Contains(str, "Service: api") {
		t.Error("missing service name")
	}

	// Check variables
	if !strings.Contains(str, "DATABASE_URL=postgres://localhost/db") {
		t.Error("missing DATABASE_URL")
	}
	if !strings.Contains(str, "API_KEY=secret_key") {
		t.Error("missing API_KEY")
	}
	if !strings.Contains(str, "DEBUG=true") {
		t.Error("missing DEBUG")
	}

	// Variables should be sorted alphabetically
	lines := strings.Split(str, "\n")
	var varLines []string
	for _, line := range lines {
		if strings.Contains(line, "=") && !strings.HasPrefix(line, "#") {
			varLines = append(varLines, line)
		}
	}

	// Check order: API_KEY, DATABASE_URL, DEBUG
	if len(varLines) != 3 {
		t.Fatalf("expected 3 variable lines, got %d", len(varLines))
	}
	if !strings.HasPrefix(varLines[0], "API_KEY=") {
		t.Errorf("first var should be API_KEY, got %s", varLines[0])
	}
	if !strings.HasPrefix(varLines[1], "DATABASE_URL=") {
		t.Errorf("second var should be DATABASE_URL, got %s", varLines[1])
	}
	if !strings.HasPrefix(varLines[2], "DEBUG=") {
		t.Errorf("third var should be DEBUG, got %s", varLines[2])
	}
}

func TestWriteServiceEnvFile_SpecialCharacters(t *testing.T) {
	tempDir := t.TempDir()

	vars := map[string]string{
		"SIMPLE":          "value",
		"WITH_SPACES":     "value with spaces",
		"WITH_QUOTES":     `value with "quotes"`,
		"WITH_NEWLINE":    "value\nwith\nnewlines",
		"WITH_BACKSLASH":  `value\with\backslash`,
		"WITH_HASH":       "value # with hash",
	}

	outputPath := filepath.Join(tempDir, ".env")
	err := writeServiceEnvFile("test", "test-context", vars, outputPath)
	if err != nil {
		t.Fatalf("writeServiceEnvFile failed: %v", err)
	}

	content, err := os.ReadFile(outputPath)
	if err != nil {
		t.Fatalf("Failed to read env file: %v", err)
	}

	str := string(content)

	// Check that simple values are not quoted
	if !strings.Contains(str, "SIMPLE=value\n") {
		t.Error("simple value should not be quoted")
	}

	// Check that values with special characters are quoted and escaped
	if !strings.Contains(str, `WITH_SPACES="value with spaces"`) {
		t.Error("value with spaces should be quoted")
	}
	if !strings.Contains(str, `WITH_QUOTES="value with \"quotes\""`) {
		t.Error("value with quotes should be quoted and escaped")
	}
	if !strings.Contains(str, `WITH_HASH="value # with hash"`) {
		t.Error("value with hash should be quoted")
	}
}

func TestNeedsQuoting(t *testing.T) {
	tests := []struct {
		value string
		want  bool
	}{
		{"simple", false},
		{"simple_value", false},
		{"simple-value", false},
		{"value123", false},
		{"value with spaces", true},
		{"value\twith\ttabs", true},
		{"value\nwith\nnewlines", true},
		{`value"with"quotes`, true},
		{"value'with'quotes", true},
		{`value\with\backslash`, true},
		{"value # with hash", true},
		{"", false},
	}

	for _, tt := range tests {
		t.Run(tt.value, func(t *testing.T) {
			got := needsQuoting(tt.value)
			if got != tt.want {
				t.Errorf("needsQuoting(%q) = %v, want %v", tt.value, got, tt.want)
			}
		})
	}
}

func TestCleanupServiceEnvFiles(t *testing.T) {
	tempDir := t.TempDir()

	// Create service env files
	servicePath := filepath.Join(tempDir, ".dual", ".local", "service")
	apiEnvPath := filepath.Join(servicePath, "api", ".env")
	webEnvPath := filepath.Join(servicePath, "web", ".env")

	err := os.MkdirAll(filepath.Dir(apiEnvPath), 0o755)
	if err != nil {
		t.Fatalf("Failed to create directory: %v", err)
	}
	err = os.MkdirAll(filepath.Dir(webEnvPath), 0o755)
	if err != nil {
		t.Fatalf("Failed to create directory: %v", err)
	}

	err = os.WriteFile(apiEnvPath, []byte("API_KEY=secret"), 0o644)
	if err != nil {
		t.Fatalf("Failed to write api env file: %v", err)
	}
	err = os.WriteFile(webEnvPath, []byte("WEB_KEY=secret"), 0o644)
	if err != nil {
		t.Fatalf("Failed to write web env file: %v", err)
	}

	// Cleanup
	err = CleanupServiceEnvFiles(tempDir)
	if err != nil {
		t.Fatalf("CleanupServiceEnvFiles failed: %v", err)
	}

	// Verify files are removed
	if _, err := os.Stat(servicePath); !os.IsNotExist(err) {
		t.Error("service directory should be removed")
	}
}

func TestCleanupServiceEnvFiles_NoFiles(t *testing.T) {
	tempDir := t.TempDir()

	// Cleanup when no files exist (should not error)
	err := CleanupServiceEnvFiles(tempDir)
	if err != nil {
		t.Fatalf("CleanupServiceEnvFiles should not error when directory doesn't exist: %v", err)
	}
}
