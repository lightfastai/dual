package env

import (
	"fmt"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"time"

	"github.com/lightfastai/dual/internal/config"
	"github.com/lightfastai/dual/internal/registry"
)

// GenerateServiceEnvFiles generates .env files for each service in .dual/.local/service/<service>/.env
// It reads environment overrides from the registry and writes only remapped variables (sparse pattern).
// Only writes files for services that have overrides.
func GenerateServiceEnvFiles(cfg *config.Config, reg *registry.Registry, projectRoot, projectIdentifier, contextName string) error {
	// Get context from registry
	ctx, err := reg.GetContext(projectIdentifier, contextName)
	if err != nil {
		// If context doesn't exist, nothing to generate
		if err == registry.ErrContextNotFound || err == registry.ErrProjectNotFound {
			return nil
		}
		return fmt.Errorf("failed to get context: %w", err)
	}

	// Get all service names from config
	serviceNames := make([]string, 0, len(cfg.Services))
	for name := range cfg.Services {
		serviceNames = append(serviceNames, name)
	}
	sort.Strings(serviceNames)

	// Generate env files for each service
	for _, serviceName := range serviceNames {
		remappedVars, err := getRemappedVarsForService(ctx, serviceName)
		if err != nil {
			return fmt.Errorf("failed to get remapped vars for service %q: %w", serviceName, err)
		}

		// Skip if no remapped variables
		if len(remappedVars) == 0 {
			continue
		}

		// Write service env file
		outputPath := filepath.Join(projectRoot, ".dual", ".local", "service", serviceName, ".env")
		if err := writeServiceEnvFile(serviceName, contextName, remappedVars, outputPath); err != nil {
			return fmt.Errorf("failed to write env file for service %q: %w", serviceName, err)
		}
	}

	return nil
}

// getRemappedVarsForService returns environment variables that have been remapped for a service.
// It merges global overrides with service-specific overrides (service-specific takes precedence).
// Returns only variables that are explicitly overridden (sparse pattern).
func getRemappedVarsForService(ctx *registry.Context, serviceName string) (map[string]string, error) {
	// Get all overrides for this service (includes global + service-specific)
	overrides := ctx.GetEnvOverrides(serviceName)

	// Exclude PORT - it's always injected at runtime, never written to files
	result := make(map[string]string)
	for k, v := range overrides {
		if k != "PORT" {
			result[k] = v
		}
	}

	return result, nil
}

// writeServiceEnvFile writes a dotenv format file with the remapped variables.
// Includes a header warning about auto-generation.
// Creates parent directories if needed.
func writeServiceEnvFile(serviceName, contextName string, vars map[string]string, outputPath string) error {
	// Create parent directory
	dir := filepath.Dir(outputPath)
	if err := os.MkdirAll(dir, 0o755); err != nil {
		return fmt.Errorf("failed to create directory: %w", err)
	}

	// Build file content
	var builder strings.Builder

	// Header
	builder.WriteString("# WARNING: This file is automatically generated by dual.\n")
	builder.WriteString("# Do not edit manually. Changes will be overwritten.\n")
	builder.WriteString("# To modify environment variables, use:\n")
	builder.WriteString("#   dual env set <key> <value>\n")
	builder.WriteString("#   dual env set --service ")
	builder.WriteString(serviceName)
	builder.WriteString(" <key> <value>\n")
	builder.WriteString("#\n")
	builder.WriteString("# Generated: ")
	builder.WriteString(time.Now().UTC().Format(time.RFC3339))
	builder.WriteString("\n")
	builder.WriteString("# Context: ")
	builder.WriteString(contextName)
	builder.WriteString("\n")
	builder.WriteString("# Service: ")
	builder.WriteString(serviceName)
	builder.WriteString("\n\n")

	// Write variables in sorted order for determinism
	keys := make([]string, 0, len(vars))
	for k := range vars {
		keys = append(keys, k)
	}
	sort.Strings(keys)

	for _, k := range keys {
		v := vars[k]
		// Quote values that contain spaces, newlines, or special characters
		if needsQuoting(v) {
			// Escape quotes and backslashes in the value
			escaped := strings.ReplaceAll(v, `\`, `\\`)
			escaped = strings.ReplaceAll(escaped, `"`, `\"`)
			builder.WriteString(k)
			builder.WriteString("=\"")
			builder.WriteString(escaped)
			builder.WriteString("\"\n")
		} else {
			builder.WriteString(k)
			builder.WriteString("=")
			builder.WriteString(v)
			builder.WriteString("\n")
		}
	}

	// Write file atomically
	tempFile := outputPath + ".tmp"
	if err := os.WriteFile(tempFile, []byte(builder.String()), 0o644); err != nil {
		return fmt.Errorf("failed to write temporary file: %w", err)
	}

	// Atomic rename
	if err := os.Rename(tempFile, outputPath); err != nil {
		_ = os.Remove(tempFile) // Clean up temp file on error
		return fmt.Errorf("failed to rename file: %w", err)
	}

	return nil
}

// needsQuoting returns true if a value needs to be quoted in dotenv format
func needsQuoting(value string) bool {
	return strings.ContainsAny(value, " \t\n\"'\\#")
}

// CleanupServiceEnvFiles removes the .dual/.local/service/ directory
func CleanupServiceEnvFiles(projectRoot string) error {
	servicePath := filepath.Join(projectRoot, ".dual", ".local", "service")

	// Check if directory exists
	if _, err := os.Stat(servicePath); os.IsNotExist(err) {
		// Nothing to clean up
		return nil
	}

	// Remove the directory and all its contents
	if err := os.RemoveAll(servicePath); err != nil {
		return fmt.Errorf("failed to remove service env files: %w", err)
	}

	return nil
}
